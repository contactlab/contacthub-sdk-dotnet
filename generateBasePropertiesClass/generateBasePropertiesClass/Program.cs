using Microsoft.CSharp;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.IO;

namespace generateBasePropertiesClass
{

    class Program
    {
        static CSharpCodeProvider cs = new CSharpCodeProvider();
        /* genera le classi per le base properties basandosi sulla definizione dinamica ottenuta da /models/properties/base */
        static void Main(string[] args)
        {
            generate();
        }


        static void generate()
        {
            BasePropertiesItem2 propertiesTree = null;
            //carica il file localmente (è stato scaricato in precedenza)
            /*
            try
            {
                StreamReader sr = new StreamReader("./example.properties_base.json");
                string jsonStr = sr.ReadToEnd();
                // properties = JsonConvert.DeserializeObject<BasePropertiesRoot>(jsonString);
                propertiesTree = JsonConvert.DeserializeObject<BasePropertiesItem2>(jsonStr);
                //propertiesTree.name = "BaseProperties";
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.ReadKey();
            }
            */

            /* scarica dinamicamente le base properties aggiornate */
            string jsonString = Connection.DoGetWebRequest("/models/properties/base");
            propertiesTree = JsonConvert.DeserializeObject<BasePropertiesItem2>(jsonString);
            propertiesTree.name = "BaseProperties";
        


            if (propertiesTree == null) return;

            //genera il file baseProperties.cs 
            string outputFileStr = String.Empty;


            outputFileStr += "/* this file is autogenerated from version 0.0.0.1 */\n\n\n";
            //         outputFileStr += "using System;\n";
            outputFileStr += "using System;\n";
            outputFileStr += "using System.Collections.Generic;\n";
            outputFileStr += "using System.Globalization;\n";
            outputFileStr += "using Newtonsoft.Json;\n";
            outputFileStr += "using System.ComponentModel.DataAnnotations;\n";
            outputFileStr += "namespace ContactHubSdkLibrary {\n";

            outputFileStr += @"
                                public class ValidatePatternAttribute : System.ComponentModel.DisplayNameAttribute
                                {
                                    public ValidatePatternAttribute(string data) : base(data) { }
                                }
            ";

            createClassFile(propertiesTree, ref outputFileStr);

            outputFileStr += "\n}\n";
            File.WriteAllText("basePropertiesClass.cs", outputFileStr);
        }



        private static string processObject(BasePropertiesItem2 p)
        {
            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }

            string processObject = "";

            if (p.description != null)
                processObject = String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
            processObject = String.Format("    public {0} {1} {{get;set;}}\n", uppercaseFirst(JsonUtil.fixName(name)), JsonUtil.fixName(name));
            return processObject;
        }

        private static string processString(BasePropertiesItem2 p)
        {
            List<String> dateTimeListField = new List<String> { "createdTime", "dateStart", "dateEnd", "updatedAt", "registeredAt", "start_date", "end_date" };

            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }
            string processString = "";

            if (!dateTimeListField.Contains(name))
            {
                if (p.pattern != null)
                {
                    processString += String.Format("\t[ValidatePattern(@\"{0}\")]\n", p.pattern);
                }
                if (p.description != null)
                    processString += String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
                processString += String.Format("    public string {0} {{get;set;}}\n", JsonUtil.fixName(name));
            }
            else //è un elenco di campi particolari che vanno renderizzati come date
            {

                processString += String.Format("    [JsonProperty(\"{0}\")]\n", name);
                processString += String.Format("    public string _{0} {{get;set;}}\n", JsonUtil.fixName(name));
                processString += String.Format("    [JsonProperty(\"_{0}\")]\n", name);
                processString += String.Format("    [JsonIgnore]\n");
                processString += @" 
                 public DateTime $NAME$
        {
            get
            {
                if (_$NAME$ != null)
                {
                    return
                         DateTime.ParseExact(_$NAME$,
                                       ""yyyy-MM-dd'T'HH:mm:ss'Z'"",
                                       CultureInfo.InvariantCulture,
                                       DateTimeStyles.AssumeUniversal |
                                       DateTimeStyles.AdjustToUniversal);
                }
                else
                {
                    return DateTime.MinValue;
                }
            }
            set
            {
                try
                {
                    _$NAME$ = value.ToString(""yyyy-MM-ddTHH\\:mm\\:ssZ"");
                }
                catch { _$NAME$ = null; }
            }
        }
            ";
            }
            processString = processString.Replace("$NAME$", name);
            return processString;
        }

        private static string processNumber(BasePropertiesItem2 p)
        {
            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }
            string processString = "";
            if (p.pattern != null)
            {
                processString += String.Format("\t[ValidatePattern(@\"{0}\")]\n", p.pattern);
            }
            if (p.description != null)
                processString += String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
            processString += String.Format("    public decimal {0} {{get;set;}}\n", JsonUtil.fixName(name));
            return processString;
        }

        private static string processBoolean(BasePropertiesItem2 p)
        {
            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }
            string processString = "";
            if (p.description != null)
                processString += String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
            processString += String.Format("    public Boolean {0} {{get;set;}}\n", JsonUtil.fixName(name));
            return processString;
        }

        private static string processEnum(BasePropertiesItem2 parent, BasePropertiesItem2 p)
        {
            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }
            string processEnum = "";
            if (p.description != null)
            {
                processEnum += String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
            }
            processEnum += String.Format("[JsonProperty(\"{0}\")]", JsonUtil.fixName(name));
            processEnum += String.Format("public string _{0} {{get;set;}}\n", JsonUtil.fixName(name));
            processEnum += String.Format("[JsonProperty(\"hidden_{0}\")]", JsonUtil.fixName(name));
            processEnum += String.Format("[JsonIgnore]");
            processEnum += String.Format(@"
                    public {0} {1} 
            {{
                get
                {{
                        {0} enumValue =ContactHubSdkLibrary.EnumHelper<{0}>.GetValueFromDisplayName(_{1});
                        return enumValue;
                }}
                set
                {{
                        var displayValue = ContactHubSdkLibrary.EnumHelper<{0}>.GetDisplayValue(value);
                        _{1} = (displayValue==""{2}""? null : displayValue);
                }}
            }}
            ", uppercaseFirst(parent.name) + uppercaseFirst(JsonUtil.fixName(name) + "Enum"), JsonUtil.fixName(name), Common.NO_VALUE);
            return processEnum;
        }

        private static string processArray(BasePropertiesItem2 p)
        {
            string name = p.name;
            if (!cs.IsValidIdentifier(name))
            {
                name = "@" + name;
            }
            string processArray = "";
            if (p.description != null)
                processArray += String.Format("\t[Display(Name=\"{0}\")]\n", p.description);
            processArray += String.Format("    public List<{0}> {1} {{get;set;}}\n", uppercaseFirst(JsonUtil.fixName(name)), JsonUtil.fixName(name));
            return processArray;
        }

        private static void createClassFile(BasePropertiesItem2 outputProperties, ref string outputFileStr, int level = 0)
        {

            outputFileStr += String.Format("\npublic class {0}\n", uppercaseFirst(outputProperties.name));
            outputFileStr += "{\n";
            List<BasePropertiesItem2> classToGenerate = new List<BasePropertiesItem2>();
            Hashtable enumToGenerate = new Hashtable();
            switch (outputProperties.type)
            {

                case "object"://è un oggetto che contiene delle properties
                    {
                        foreach (BasePropertiesItem2 p in outputProperties.properties)
                        {
                            //se è un contenitore, allora processa le properties all'interno
                            switch (p.type)
                            {
                                case "object":
                                    {
                                        outputFileStr += processObject(p);
                                        classToGenerate.Add(p);
                                    }
                                    break;
                                case "number":
                                case "integer":
                                    {
                                        outputFileStr += processNumber(p);
                                    }
                                    break;
                                case "boolean":
                                    {
                                        outputFileStr += processBoolean(p);
                                    }
                                    break;
                                case "string":
                                    {
                                        if (p.@enum == null) //stringa normale
                                        {
                                            outputFileStr += processString(p);
                                        }
                                        else  //è un enum su base stringa 
                                        {
                                            outputFileStr += processEnum(outputProperties, p);
                                            //crea un enum che ha nel nome anche il padre, per evitare definizioni doppie di oggetti diversi con lo stesso nome
                                            enumToGenerate.Add(uppercaseFirst(outputProperties.name) + uppercaseFirst(JsonUtil.fixName(p.name) + "Enum"), p.@enum);
                                        }
                                    }
                                    break;
                                case "array":
                                    {

                                        //items contiene la definizione della classe che compone l'arrayy
                                        p.items.name = p.name;
                                        p.items.description = p.description;
                                        outputFileStr += processArray(p);
                                        classToGenerate.Add(p.items);
                                    }
                                    break;
                                default:
                                    //error other types
                                    break;

                            }
                        }
                    }
                    break;
                default:
                    {
                        var x = outputProperties.type;
                    }
                    break;

            }

            outputFileStr += "}\n\n";
            //processa le classi figli che ha trovato
            foreach (BasePropertiesItem2 p in classToGenerate)
            {
                createClassFile(p, ref outputFileStr, level++);
            }

            //processa gli enum che ha trovato
            foreach (DictionaryEntry e in enumToGenerate)
            {
                createEnumFile(e, ref outputFileStr);
            }
        }

        static void createEnumFile(DictionaryEntry enumObj, ref string outputFileStr)
        {

            string key = enumObj.Key.ToString();
            if (!cs.IsValidIdentifier(key))
            {
                key = "@" + key;
            }
            outputFileStr += String.Format("public enum {0} {{\n", key);
            outputFileStr += String.Format("\t{0},\n", Common.NO_VALUE);
            foreach (string enumItem in (string[])enumObj.Value)
            {
                outputFileStr += String.Format("\t[Display(Name=\"{0}\")]\n", enumItem);
                outputFileStr += String.Format("\t{0},\n", Common.makeValidFileName(enumItem));
            }
            if (outputFileStr.EndsWith(",\n"))
            {
                outputFileStr = outputFileStr.Substring(0, outputFileStr.Length - 2);
            }

            outputFileStr += String.Format("\n}}");
        }

        static string uppercaseFirst(string s)
        {
            // Check for empty string.
            if (string.IsNullOrEmpty(s))
            {
                return string.Empty;
            }
            // Return char and concat substring.
            return char.ToUpper(s[0]) + s.Substring(1);
        }
    }
}
